title:: Sdef
summary:: named definition of signal
categories:: Libraries>JITLib>NodeProxy
related:: Classes/Signal

description::
tady bude komentar

code::
Sdef(\key, duration, items)	//store new signal definition
Sdef(\key)	                // get the definition
::

tady bude komentar

ClassMethods::

private::initClass, initSynthDefs, library

subsection::Creation

method::new
Store new signal definition named by key to library and returns the instance of them. If there is already an Sdef there with same key, replace its object with the new one.

argument::key
name of signal definition. Key can be defined in multilevel form as array too.
code::
Sdef(\someName)
Sdef([\someFolder, \someName_A])
Sdef([\someFolder, \someName_B])
::

argument::dur
new signal duration

argument::... args
Objects for derivation a signal. Supported forms are displayed below

definitionList::
## Sdef: || Other signal definitions
code::
Sdef(\x, 4, Sdef.ramp(0,1,3,0.5)).plot
::

## Env: || Signal from envelope
code::
Sdef(\x, 4, Env([0,1,0.65,0], [0.6,1.1,2.3], [4, \sin, -8])).plot
::

## Integer or Float: || Level of constant signal
code::
Sdef(\x, 4, 0.3).plot
::

## UGen:  || NOT WORK YET
## Pbind:  || NOT WORK YET
::

subsection::Empty definitions

If Sdef is defined without name, that definition is not stored in library. But this definition could be use like source of data for other Sdef. Empty named Sdef cannot be a target of reference chain directly.

method::level

method::env

method::ramp


subsection::Information

method::exist
If signal definition named by key is store in library yet, returns true. Else false.

argument::key
the name of the instance (symbol or array)
code::
Sdef.exist(\x) // get the proxy
::

method::printAll
Print all stored signals from library. Style like .postTree

code::
Sdef.printAll
::

InstanceMethods::
private::prSetSignal, addRef, updateRefs, path


subsection::Informations

method::plot
plot a view of signal

method::duration
return signal time duration

method::size
return frames count of signal



subsection::Signal definition

method::level
Set constat value for signal
code::
Sdef(\x).level(0.2, 1.5, 0.5).plot;
::
argument::level
value of signal level
argument::dur
duration of signal
argument::shift
shift of signal start



method::env
Set value for signal from envelope. Detail envelope description at link::Classes/Env#*new::
code::
Sdef(\x).env([0,1,0.5,0], [0.2,0.5,0.3], [8, \sin, -5]).plot;
::
argument::levels
an array of signal levels
argument::times
an array of signal segment duration
argument::curves
an array of signal segment curvature
argument::shift
shift of signal start



section::Envelopes control structure

definitionList::

## node.env
|| Set the one named proxy control by Env. This envelope is define by target namedControl variable code::\set::. Optional this envelope can have symbol of name used for later calling.

code::
a = NodeProxy(s);
a[0] = { |freq = 440, dt=0.1, rate=2| Ringz.ar(Impulse.ar(rate * [1, 1.2]), freq, dt)*0.1 };
a.play;
::

## node.cycle -> event pattern
|| Set the proxy controls with an event pattern of type code::\set::. Old values are kept, only those explicitly provided are overridden.



## node.stage -> event pattern
|| Set the proxy controls with an event pattern of type code::\set::. Old values are kept, only those explicitly provided are overridden.



::

Examples::

code::
Sdef(\test1, \amp1).set(Env([0,2,0.5,0], [1,1,1], [5, -3, -3]))
Sdef(\test1, \amp1).path
Sdef(\test1, \amp1).plot

Sdef(\test).updatePlot(true)
(
Sdef(\test).setn(
	0, Env([0,1,0.3,0], [1,1,1], [5, -3, -3]).duplicate(35),
	5, Env([0,0.5,0], [20,20], \sin),
	40, Env([0,1.5,0.5,0], [1,5,1], [5, -3, -3]),
)
)

Sdef(\e2).level(0.5, 2)
Sdef(\e1).set(Env([0,1,0.5,0], [1,4,1], [5, -8, -3]))
Sdef(\e3).set(Env([0,0.2,0], [5,5], \sin))

Sdef(\cycle).updatePlot(true)
(
Sdef(\cycle).setn(
	1, Sdef(\e1),
	0.5, Sdef(\e3),
	8, Sdef(\e1),
	5.5, Sdef(\e2),
)
)
Sdef.print
Sdef(\root,\e1 , \amp1).set(Env([0,1,0.5,0], [1,4,1], [5, -8, -3]))
Sdef(\root,\e2).set(Env([0,1,0.5,0], [1,4,1], [5, -8, -3]))
Sdef(\root).fill(3, 0.3)
Sdef.exist([\e3])
Sdef(\e1).references
Sdef(\cycle).references
::
