title:: Sdef
summary:: definition of named signal
categories:: Libraries>JITLib>NodeProxy
related:: Classes/Signal

description::
Reference to a proxy, forms an alternative to link::Classes/ProxySpace::. All methods are inherited from link::Classes/NodeProxy::.

code::
Sdef(path)	        //returns the instance
Sdef(path, item)	//convert item to signal and returns the instance
::

Similar to Adverbs (see link::Guides/J-concepts-in-SC::), roles allow to specify how a source for a link::Classes/NodeProxy:: is being used. A role is an association of a link::Classes/Symbol:: and the new proxy source object.

The below examples can equally be used for link::Classes/Ndef:: and in link::Classes/ProxySpace::.

code::
// Thus, the following expressions behave in an equivalent way:

a = NodeProxy(s);
a[0] = ...

ProxySpace.push(s);
~a[0] = ...

Ndef(\a, ...)
::

ClassMethods::

private::initClass
private::library

subsection::Access

method::new
Return a new node proxy and store it in a global ProxySpace under the key. If there is already an Ndef there, replace its object with the new one. The object can be any supported class, see link::Classes/NodeProxy#Supported sources:: help.

argument::... path
the name of the proxy (a symbol). It returns the proxy object:
code::
Sdef(\x) // get the proxy
::

Path can be defined in multilevel form, like (\path1, \path2).
code::
Sdef(\myFolder)              // get the item on this addres
Sdef(\myFolder, \x)          // get the item on this addres
Sdef(\myFolder, \y, \test1)  // get the item on this addres
Sdef(\myFolder, \y, \test2)  // get the item on this addres
::

subsection::Information

method::exist
Return a new signal proxy and store it in a global library under the key.

argument::path
the name of the proxy (usually a symbol). If only the key is given and no object, it returns the proxy object:
code::
Sdef.exist(\x) // get the proxy
::

method::printAll
Print all stored signals from library. Style like .postTree

code::
Sdef.printAll
::

InstanceMethods::

private::prSetSignal, addRef, updateRefs

subsection::Informations

method::plot
Plot a view of signal

method::duration
Return duration of signal

subsection::Signal definition



method::level
Set constat value for signal

code::
Sdef(\x).level(0.2, 1.5, 0.5).plot;
::

argument::level
Value of signal level
argument::dur
Duration of signal
argument::shift
Shift of signal start



method::env
Set value for signal from envelope. Detail envelope description at link::Classes/Env#*new::

code::
Sdef(\x).env([0,1,0.5,0], [0.2,0.5,0.3], [8, \sin, -5]).plot;
::

argument::levels
an array of signal levels
argument::times
an array of signal segment duration
argument::curves
an array of signal segment curvature
argument::shift
Shift of signal start



section::Envelopes control structure

definitionList::

## node.env
|| Set the one named proxy control by Env. This envelope is define by target namedControl variable code::\set::. Optional this envelope can have symbol of name used for later calling.

code::
a = NodeProxy(s);
a[0] = { |freq = 440, dt=0.1, rate=2| Ringz.ar(Impulse.ar(rate * [1, 1.2]), freq, dt)*0.1 };
a.play;
::

## node.cycle -> event pattern
|| Set the proxy controls with an event pattern of type code::\set::. Old values are kept, only those explicitly provided are overridden.



## node.stage -> event pattern
|| Set the proxy controls with an event pattern of type code::\set::. Old values are kept, only those explicitly provided are overridden.



::

Examples::

code::
Sdef(\test1, \amp1).set(Env([0,2,0.5,0], [1,1,1], [5, -3, -3]))
Sdef(\test1, \amp1).path
Sdef(\test1, \amp1).plot

Sdef(\test).updatePlot(true)
(
Sdef(\test).setn(
	0, Env([0,1,0.3,0], [1,1,1], [5, -3, -3]).duplicate(35),
	5, Env([0,0.5,0], [20,20], \sin),
	40, Env([0,1.5,0.5,0], [1,5,1], [5, -3, -3]),
)
)

Sdef(\e2).level(0.5, 2)
Sdef(\e1).set(Env([0,1,0.5,0], [1,4,1], [5, -8, -3]))
Sdef(\e3).set(Env([0,0.2,0], [5,5], \sin))

Sdef(\cycle).updatePlot(true)
(
Sdef(\cycle).setn(
	1, Sdef(\e1),
	0.5, Sdef(\e3),
	8, Sdef(\e1),
	5.5, Sdef(\e2),
)
)
Sdef.print
Sdef(\root,\e1 , \amp1).set(Env([0,1,0.5,0], [1,4,1], [5, -8, -3]))
Sdef(\root,\e2).set(Env([0,1,0.5,0], [1,4,1], [5, -8, -3]))
Sdef(\root).fill(3, 0.3)
Sdef.exist([\e3])
Sdef(\e1).references
Sdef(\cycle).references
::
