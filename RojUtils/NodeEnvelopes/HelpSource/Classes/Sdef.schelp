title:: Sdef
summary:: named definition of signal
categories:: Libraries>RojUtils
related:: Classes/Signal

description::
tady bude komentar

code::
Sdef(\key, duration, items)	//store new signal definition
Sdef(\key)	                // get the definition
::

tady bude komentar

ClassMethods::

private::initClass, initSynthDefs, library, frame

subsection::Creation

method::new
Store new signal definition named by key to library and returns the instance of them. If there is already an Sdef there with same key, replace its object with the new one.

argument::key
name of signal definition. Key can be defined in multilevel form as array too.
code::
Sdef(\someName)
Sdef([\someFolder, \someName_A])
Sdef([\someFolder, \someName_B])
::

argument::dur
new signal duration

argument::... args
Objects for derivation a signal. Supported forms are displayed below

definitionList::
## Sdef: || Other signal definitions
code::
Sdef(\x, 4, Sdef.ramp(0,1,3,0.5)).plot
::

## Env: || Signal from envelope
code::
Sdef(\x, 4, Env([0,1,0.65,0], [0.6,1.1,2.3], [4, \sin, -8])).plot
::

## Integer or Float: || Level of constant signal
code::
Sdef(\x, 4, 0.3).plot
::

## UGen:  || NOT WORK YET
## Pbind:  || NOT WORK YET
::


subsection::Empty definitions

If Sdef is defined without name, that definition is not stored in library.
But this definition could be use like source of data for other Sdef.
Empty named Sdef cannot be a target of reference chain directly.
code::
 // 3 equivalent way how get empty Sdef
a = Sdef.new
a = Sdef()
a = Sdef(nil)
::

method::level
Return new instance of signal definition and set signal by constat value. This definition is not stored in library.
code::
Sdef.level(0.2, 1.5, 0.5).plot;
::
argument::level
value of signal level
argument::dur
duration of signal
argument::offset
offset of signal start

method::env
Return new instance of signal definition and set signal by envelope. This definition is not stored in library. Detail envelope description at link::Classes/Env#*new::
code::
Sdef.env([0,1,0.5,0], [0.2,0.5,0.3], [8, \sin, -5]).plot;
::
argument::levels
an array of signal levels
argument::times
an array of signal segment duration
argument::curves
an array of signal segment curvature
argument::offset
offset of signal start

method::ramp
Return new instance of signal definition and set signal by start and end level. This definition is not stored in library.
code::
Sdef.ramp(0.6,0.2,1,0.5).plot;
::
argument::from
value of signal level at start
argument::to
value of signal level at end
argument::dur
duration of signal
argument::offset
offset of signal start


subsection::Information

method::exist
If signal definition named by key is store in library yet, return it. Else return nil.
code::
Sdef.exist(\x) // return nil
Sdef(\x)
Sdef.exist(\x) // return Sdef(\x)
::
argument::key
the name of the instance (symbol or array)

method::printAll
Print all stored signals definition from library. Style like .postTree
code::
Sdef.printAll
::



InstanceMethods::
private::prSetSignal, addRef, updateRefs, path

method::key
Rename instance and store new definition to library. Old definition is delete from library.
code::
a = Sdef.new
a.key = \x
Sdef.printAll
::
argument::name
name of signal definition

method::duration
code::
a = Sdef.new
a.duration = 6
a.plot
::
Set time limitation for this definition and prepare new signal with this time duration.
argument::dur
duration of signal definition

method::size
return nuber of frames in signal

method::plot
plot a preview of signal
argument::update
regenerate preview of signal when some reference was changed


subsection::References

code::
Sdef(\x, 2).parents
Sdef(\y, 8).parents
Sdef(\z, 10, Sdef(\x), Sdef(\y)).children

Sdef(\x).parents
Sdef(\y).parents
::

method::parents

method::children








section::Envelopes control structure

definitionList::

## node.env
|| Set the one named proxy control by Env. This envelope is define by target namedControl variable code::\set::. Optional this envelope can have symbol of name used for later calling.

code::
a = NodeProxy(s);
a[0] = { |freq = 440, dt=0.1, rate=2| Ringz.ar(Impulse.ar(rate * [1, 1.2]), freq, dt)*0.1 };
a.play;
::

## node.cycle -> event pattern
|| Set the proxy controls with an event pattern of type code::\set::. Old values are kept, only those explicitly provided are overridden.



## node.stage -> event pattern
|| Set the proxy controls with an event pattern of type code::\set::. Old values are kept, only those explicitly provided are overridden.



::

Examples::

code::
Sdef(\test1, \amp1).set(Env([0,2,0.5,0], [1,1,1], [5, -3, -3]))
Sdef(\test1, \amp1).path
Sdef(\test1, \amp1).plot

Sdef(\test).updatePlot(true)
(
Sdef(\test).setn(
	0, Env([0,1,0.3,0], [1,1,1], [5, -3, -3]).duplicate(35),
	5, Env([0,0.5,0], [20,20], \sin),
	40, Env([0,1.5,0.5,0], [1,5,1], [5, -3, -3]),
)
)

Sdef(\e2).level(0.5, 2)
Sdef(\e1).set(Env([0,1,0.5,0], [1,4,1], [5, -8, -3]))
Sdef(\e3).set(Env([0,0.2,0], [5,5], \sin))

Sdef(\cycle).updatePlot(true)
(
Sdef(\cycle).setn(
	1, Sdef(\e1),
	0.5, Sdef(\e3),
	8, Sdef(\e1),
	5.5, Sdef(\e2),
)
)
Sdef.print
Sdef(\root,\e1 , \amp1).set(Env([0,1,0.5,0], [1,4,1], [5, -8, -3]))
Sdef(\root,\e2).set(Env([0,1,0.5,0], [1,4,1], [5, -8, -3]))
Sdef(\root).fill(3, 0.3)
Sdef.exist([\e3])
Sdef(\e1).references
Sdef(\cycle).references
::
